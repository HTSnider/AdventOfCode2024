# AdventOfCode2024
My solutions for Advent of Code 2024 (https://adventofcode.com/), this year written in Java for practice.
Input files are not included per contest rules.

## Day 5: 
The first notable day. I completed the first part using regex to evaluate the following of the ordering rules, which turned out to be completely incompatible with part 2. 
My part 2 is follows the solution of another participant, where the rules of ordering are expressed as which pages must precede each page, and this is used to calculate the minimum index the page must go in the correct ordering, which is then used to sort the update.

## Day 6:
Another notable day. The solution to both parts was solved with brute force, with a clever trick in part 2 of hashing the position and direction of points the guard turns at, so a position could be checked faster than putting it in a set of visited coordinates.

## Day 7:
First day to use recursion this year. The maximum depth is quite low, so the only optimization was using || so only paths until the first correct path are evaluated. Another optimization could have been to cut off the recursion if the running total excceeds the target value, since all of the operations are monotomically increasing.

## Day 8:
This day was difficult, but only because I tricked myself into thinking I needed to reduce the distance vector between each pair of antenni by the greatest common denominator, to find antinodes in spaces that exactly intersect the line between the antenni. One little problem I just added a check for was the duplication of antenna coordinates, since it shouldn't be possible to happen, and yet it does.

## Day 9:
Another tricky day, manipulating large arrays of objects in loops. Switching from for to while loops made iterating through the files and blocks less complex, and a HashSet made determining which files I had already attempted to move much quicker.

## Day 10: 
A bit tricky to grasp, but not difficult to implement. Because part 2 was just part 1 without a check, I was able to optimize it a bit. A further optimization I could make is replacing the ArrayList I used to store steps of each path with a Queue, for faster list operations.

## Day 11:
I really struggled with this day, mostly part 2. My initial approach of keeping an ArrayDeque<Long> of the stones worked fine for 25 steps, but took up too much memory at 75 steps. Implementing the new process, keeping stones in a dictionary (implemented as a HashMap), with each stone markings being the key, and number of stones with that marking being the value, introduced logic errors, and I had to run someone else's solution in a separate project and manually compare the values in the dicts at each step to find and fix the problem.

## Day 12:
I completed the first part easily with a flooding algorithm. The second part was a little harder, requiring me to create sets of vertical and horizontal edges, then find which ones were adjacent, and also to find where four edges meet to take corners within the region into account.

## Day 13:
A frustrating day. While finding the solution mathematically wasn't difficult, getting the numbers to compute without rounding errors took longer than it should have. However, once part 1 was working, part 2 only needed a single modification.

## Day 14:
While part 1 was trivial, I barely knew where to start with part 2. I tried minimizing the mean horizontal difference first, but I would have been better off with some kind of clustering score. In the end the solution was to minimize the safety score I calculated in part 1, which I suppose should have been a hint.

## Day 17:
While part 1 was simple, part 2 had me stumped for a while. After attempting to derive the math behind my program input, I implemented BFS using the output from part 1, and then had to convert the whole thing to use BigInteger because the so-called Integer registers actually were required to hold numbers larger than an Integer.

## Day 18:
A much easier day than expected. Part 1 was another BFS through a maze, though this one was generated by the first 1028 inputs. I was expecting part 2 to be similar, with the maze gaining another fallen byte every step, but instead it was a binary sort to find the first block that would make the end of the maze unreachable.

## Day 19:
This day was a little tricky, as my first attempt to create a target string by adding and comparing substrings was slow and memory-intensive. After I realized I could just store the ending indexes of each slice, and compare only the next prospective compenent sequence to its equivalent substring, things went a lot smoother. For part 2, I improved this even furthur by using dynamic programming, keeping an array of the number of ways to reach each index, and adding the value at the index I was evaluating to the value of that index plus the length of the current piece, for each piece where the substring matched.

## Day 20:
A surprisingly tricky part 1. I was able to calculate how many steps a cheat saves by finding the distance from the start to each node, and the end to each node, using Dijkstra's algorithm. Once the part 1 solution for cheats of length <=2 worked, the part 2 solution for cheats of length <=20 was not difficult to implement, though running a bit slower because of nested for loops. Some space could be saved by counting the cheats that save 100+ steps as they are calculated, but I'm not sure how to do this faster with Java.

## Day 21:
Surprisingly difficult, but the most difficult part was ordering the movements to ensure both that the arm could move between buttons without passing over the empty space, and that the movements are optimal. Then part 2 was a matter of converting the existing functions to work with an input HashMap instead of a global variable, and to use Long rather than Integer to hold the values.

## Day 22:
Today was fairly easy. I was able to optimize part 2 by only storing the last 5 secret numbers in a sliding window, and adding the first occurrance of each sequence of 4 changes to a HashMap of sequence to total profits. The functions still run slower than I would like, but the only method I see to further improve things would be to derive the expected change in price each evolution by its modular arithmetic, or possibly remove unnecessary portions of the secret numbers.

## Day 23:
Today focused on an undirected graph, and introduced me to the Bron-Kerbosch algorithm for finding the maximal clique.I implemented the first version, because I couldnt find any detail on how to chooose a pivot, and it didnt seem to work correctly with a random choice.

## Day 24:
The part 2 of today was a reverse engineering challenge, focused on finding what gates have had their outputs swapped in the given circuit, when knowing that the circuit is intended to be an adder. This would have been a lot easier on paper, or in a proper circuit analyzer, manually inspecting each half adder for where its sum and carry bits were going. Still, it's the final stretch now.

